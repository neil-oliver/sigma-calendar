{"ast":null,"code":"import { getColumnName, validateRequiredColumns, parseDate, isValidDate, getEventColor, debugEventProcessing } from './columnHelper';\nimport { addDays, format, startOfDay, endOfDay } from 'date-fns';\n\n/**\n * Process Sigma data into calendar events structure\n * @param {Object} sigmaData - Sigma data object with column arrays\n * @param {Object} config - Configuration object with column names\n * @param {Object} settings - Settings object\n * @param {Object} elementColumns - Column information from getElementColumns\n * @returns {Object} - { events, categories } or null if no valid data\n */\nexport function processCalendarData(sigmaData, config, settings, elementColumns) {\n  if (!sigmaData || !config.title || !config.startDate || !elementColumns) {\n    console.warn('Missing required data for calendar processing:', {\n      hasSigmaData: !!sigmaData,\n      hasTitle: !!config.title,\n      hasStartDate: !!config.startDate,\n      hasElementColumns: !!elementColumns\n    });\n    return null;\n  }\n\n  // Validate that all required columns exist\n  const requiredColumns = [config.title, config.startDate];\n\n  // Add optional columns to validation if they exist\n  if (config.ID) requiredColumns.push(config.ID);\n  if (config.endDate) requiredColumns.push(config.endDate);\n  if (config.description) requiredColumns.push(config.description);\n  if (config.category) requiredColumns.push(config.category);\n  if (config.eventFields && Array.isArray(config.eventFields)) {\n    requiredColumns.push(...config.eventFields);\n  }\n  const columnValidation = validateRequiredColumns(elementColumns, requiredColumns);\n  if (!columnValidation.isValid) {\n    console.warn('Missing required columns:', columnValidation.missingColumns);\n    return null;\n  }\n\n  // Get column data using column keys\n  const titleData = sigmaData[config.title] || [];\n  const startDateData = sigmaData[config.startDate] || [];\n  const endDateData = config.endDate ? sigmaData[config.endDate] || [] : null;\n  const descriptionData = config.description ? sigmaData[config.description] || [] : null;\n  const categoryData = config.category ? sigmaData[config.category] || [] : null;\n  const idData = config.ID ? sigmaData[config.ID] || [] : null;\n  if (titleData.length === 0 || startDateData.length === 0) {\n    console.warn('No title or start date data found');\n    return null;\n  }\n\n  // Process additional event fields\n  const eventFieldsData = {};\n  if (config.eventFields && Array.isArray(config.eventFields)) {\n    config.eventFields.forEach(fieldKey => {\n      if (sigmaData[fieldKey]) {\n        eventFieldsData[fieldKey] = sigmaData[fieldKey];\n      }\n    });\n  }\n\n  // Create events\n  const events = [];\n  const categories = new Set();\n  const dataLength = titleData.length;\n  for (let i = 0; i < dataLength; i++) {\n    const title = titleData[i];\n    const startDateValue = startDateData[i];\n\n    // Skip if no title or start date\n    if (!title || !startDateValue) continue;\n\n    // Parse start date\n    const startDate = parseDate(startDateValue);\n    if (!startDate) {\n      console.warn(`Invalid start date at index ${i}:`, startDateValue);\n      continue;\n    }\n\n    // Parse end date if provided, otherwise use start date\n    let endDate = startDate;\n    if (endDateData && endDateData[i]) {\n      const parsedEndDate = parseDate(endDateData[i]);\n      if (parsedEndDate) {\n        endDate = parsedEndDate;\n      }\n    }\n\n    // Get other fields\n    const description = descriptionData && descriptionData[i] ? String(descriptionData[i]) : '';\n    const category = categoryData && categoryData[i] ? String(categoryData[i]) : 'Default';\n    const eventId = idData && idData[i] != null ? idData[i] : i;\n\n    // Add category to set\n    categories.add(category);\n\n    // Extract additional event fields\n    const additionalFields = {};\n    if (config.eventFields && Array.isArray(config.eventFields)) {\n      config.eventFields.forEach(fieldKey => {\n        if (eventFieldsData[fieldKey] && eventFieldsData[fieldKey][i] != null) {\n          const fieldName = getColumnName(elementColumns, fieldKey);\n          additionalFields[fieldName] = String(eventFieldsData[fieldKey][i]);\n        }\n      });\n    }\n\n    // Determine if this is an all-day event\n    const isAllDay = !hasTimeComponent(startDateValue) && !hasTimeComponent(endDateData === null || endDateData === void 0 ? void 0 : endDateData[i]);\n\n    // Create event object\n    const event = {\n      id: eventId,\n      title: String(title),\n      start: startDate,\n      end: endDate,\n      allDay: isAllDay,\n      description,\n      category,\n      color: getEventColor(category, settings),\n      additionalFields,\n      originalIndex: i\n    };\n\n    // Debug event processing in development\n    if (process.env.NODE_ENV === 'development' && i < 3) {\n      debugEventProcessing(event, config, elementColumns);\n    }\n    events.push(event);\n  }\n\n  // Sort events by start date\n  events.sort((a, b) => a.start.getTime() - b.start.getTime());\n  console.log(`Processed ${events.length} events from ${dataLength} rows`);\n  return {\n    events,\n    categories: Array.from(categories),\n    stats: {\n      totalEvents: events.length,\n      totalRows: dataLength,\n      dateRange: events.length > 0 ? {\n        start: events[0].start,\n        end: events[events.length - 1].end\n      } : null\n    }\n  };\n}\n\n/**\n * Check if a date value has a time component\n * @param {any} dateValue - Date value to check\n * @returns {boolean} - True if has time component\n */\nfunction hasTimeComponent(dateValue) {\n  if (!dateValue) return false;\n  const date = parseDate(dateValue);\n  if (!date) return false;\n\n  // Check if time is not midnight (00:00:00)\n  return date.getHours() !== 0 || date.getMinutes() !== 0 || date.getSeconds() !== 0;\n}\n\n/**\n * Generate sample events for development/testing\n * @param {Date} startDate - Start date for sample events\n * @param {number} count - Number of events to generate\n * @returns {Object} - Calendar data with sample events\n */\nexport function generateSampleEvents(startDate = new Date(), count = 10) {\n  const events = [];\n  const categories = ['Meeting', 'Task', 'Deadline', 'Event', 'Review'];\n  const colors = ['#3788d8', '#f97316', '#ef4444', '#22c55e', '#8b5cf6'];\n  for (let i = 0; i < count; i++) {\n    const eventStart = addDays(startDate, Math.floor(Math.random() * 30));\n    const category = categories[Math.floor(Math.random() * categories.length)];\n    events.push({\n      id: i + 1,\n      title: `Sample Event ${i + 1}`,\n      start: eventStart,\n      end: Math.random() > 0.7 ? addDays(eventStart, Math.floor(Math.random() * 3) + 1) : eventStart,\n      allDay: Math.random() > 0.5,\n      description: `This is a sample event description for event ${i + 1}`,\n      category,\n      color: colors[categories.indexOf(category)],\n      additionalFields: {\n        'Priority': ['Low', 'Medium', 'High'][Math.floor(Math.random() * 3)],\n        'Assignee': ['John Doe', 'Jane Smith', 'Bob Johnson'][Math.floor(Math.random() * 3)]\n      },\n      originalIndex: i\n    });\n  }\n  return {\n    events: events.sort((a, b) => a.start.getTime() - b.start.getTime()),\n    categories,\n    stats: {\n      totalEvents: events.length,\n      totalRows: events.length,\n      dateRange: {\n        start: events[0].start,\n        end: events[events.length - 1].end\n      }\n    }\n  };\n}\n\n/**\n * Filter events by date range\n * @param {Array} events - Array of events\n * @param {Date} startDate - Start date of range\n * @param {Date} endDate - End date of range\n * @returns {Array} - Filtered events\n */\nexport function filterEventsByDateRange(events, startDate, endDate) {\n  if (!events || !Array.isArray(events)) return [];\n  return events.filter(event => {\n    const eventStart = event.start;\n    const eventEnd = event.end || event.start;\n\n    // Event overlaps with the date range\n    return eventStart <= endDate && eventEnd >= startDate;\n  });\n}\n\n/**\n * Group events by date\n * @param {Array} events - Array of events\n * @returns {Object} - Events grouped by date string (YYYY-MM-DD)\n */\nexport function groupEventsByDate(events) {\n  if (!events || !Array.isArray(events)) return {};\n  const grouped = {};\n  events.forEach(event => {\n    const dateKey = format(event.start, 'yyyy-MM-dd');\n    if (!grouped[dateKey]) {\n      grouped[dateKey] = [];\n    }\n    grouped[dateKey].push(event);\n  });\n  return grouped;\n}\n\n/**\n * Get events for a specific date\n * @param {Array} events - Array of events\n * @param {Date} date - Date to get events for\n * @returns {Array} - Events for the date\n */\nexport function getEventsForDate(events, date) {\n  if (!events || !Array.isArray(events) || !date) return [];\n  const targetDate = startOfDay(date);\n  const nextDate = endOfDay(date);\n  return events.filter(event => {\n    const eventStart = startOfDay(event.start);\n    const eventEnd = endOfDay(event.end || event.start);\n\n    // Check if event spans this date\n    return eventStart <= targetDate && eventEnd >= targetDate;\n  });\n}\n\n/**\n * Validate calendar configuration\n * @param {Object} config - Configuration object\n * @returns {Object} - { isValid, errors }\n */\nexport function validateCalendarConfig(config) {\n  const errors = [];\n  if (!config.source) {\n    errors.push('Data source is required');\n  }\n  if (!config.title) {\n    errors.push('Event title column is required');\n  }\n  if (!config.startDate) {\n    errors.push('Start date column is required');\n  }\n  return {\n    isValid: errors.length === 0,\n    errors\n  };\n}","map":{"version":3,"names":["getColumnName","validateRequiredColumns","parseDate","isValidDate","getEventColor","debugEventProcessing","addDays","format","startOfDay","endOfDay","processCalendarData","sigmaData","config","settings","elementColumns","title","startDate","console","warn","hasSigmaData","hasTitle","hasStartDate","hasElementColumns","requiredColumns","ID","push","endDate","description","category","eventFields","Array","isArray","columnValidation","isValid","missingColumns","titleData","startDateData","endDateData","descriptionData","categoryData","idData","length","eventFieldsData","forEach","fieldKey","events","categories","Set","dataLength","i","startDateValue","parsedEndDate","String","eventId","add","additionalFields","fieldName","isAllDay","hasTimeComponent","event","id","start","end","allDay","color","originalIndex","process","env","NODE_ENV","sort","a","b","getTime","log","from","stats","totalEvents","totalRows","dateRange","dateValue","date","getHours","getMinutes","getSeconds","generateSampleEvents","Date","count","colors","eventStart","Math","floor","random","indexOf","filterEventsByDateRange","filter","eventEnd","groupEventsByDate","grouped","dateKey","getEventsForDate","targetDate","nextDate","validateCalendarConfig","errors","source"],"sources":["/Users/neil/Documents/GitHub/sigma-calendar/sigma-calendar/src/utils/dataProcessor.js"],"sourcesContent":["import { \n  getColumnName, \n  validateRequiredColumns, \n  parseDate, \n  isValidDate, \n  getEventColor,\n  debugEventProcessing \n} from './columnHelper';\nimport { addDays, format, startOfDay, endOfDay } from 'date-fns';\n\n/**\n * Process Sigma data into calendar events structure\n * @param {Object} sigmaData - Sigma data object with column arrays\n * @param {Object} config - Configuration object with column names\n * @param {Object} settings - Settings object\n * @param {Object} elementColumns - Column information from getElementColumns\n * @returns {Object} - { events, categories } or null if no valid data\n */\nexport function processCalendarData(sigmaData, config, settings, elementColumns) {\n  if (!sigmaData || !config.title || !config.startDate || !elementColumns) {\n    console.warn('Missing required data for calendar processing:', {\n      hasSigmaData: !!sigmaData,\n      hasTitle: !!config.title,\n      hasStartDate: !!config.startDate,\n      hasElementColumns: !!elementColumns\n    });\n    return null;\n  }\n\n  // Validate that all required columns exist\n  const requiredColumns = [config.title, config.startDate];\n  \n  // Add optional columns to validation if they exist\n  if (config.ID) requiredColumns.push(config.ID);\n  if (config.endDate) requiredColumns.push(config.endDate);\n  if (config.description) requiredColumns.push(config.description);\n  if (config.category) requiredColumns.push(config.category);\n  if (config.eventFields && Array.isArray(config.eventFields)) {\n    requiredColumns.push(...config.eventFields);\n  }\n  \n  const columnValidation = validateRequiredColumns(elementColumns, requiredColumns);\n  if (!columnValidation.isValid) {\n    console.warn('Missing required columns:', columnValidation.missingColumns);\n    return null;\n  }\n\n  // Get column data using column keys\n  const titleData = sigmaData[config.title] || [];\n  const startDateData = sigmaData[config.startDate] || [];\n  const endDateData = config.endDate ? (sigmaData[config.endDate] || []) : null;\n  const descriptionData = config.description ? (sigmaData[config.description] || []) : null;\n  const categoryData = config.category ? (sigmaData[config.category] || []) : null;\n  const idData = config.ID ? (sigmaData[config.ID] || []) : null;\n\n  if (titleData.length === 0 || startDateData.length === 0) {\n    console.warn('No title or start date data found');\n    return null;\n  }\n\n  // Process additional event fields\n  const eventFieldsData = {};\n  if (config.eventFields && Array.isArray(config.eventFields)) {\n    config.eventFields.forEach(fieldKey => {\n      if (sigmaData[fieldKey]) {\n        eventFieldsData[fieldKey] = sigmaData[fieldKey];\n      }\n    });\n  }\n\n  // Create events\n  const events = [];\n  const categories = new Set();\n  const dataLength = titleData.length;\n\n  for (let i = 0; i < dataLength; i++) {\n    const title = titleData[i];\n    const startDateValue = startDateData[i];\n    \n    // Skip if no title or start date\n    if (!title || !startDateValue) continue;\n\n    // Parse start date\n    const startDate = parseDate(startDateValue);\n    if (!startDate) {\n      console.warn(`Invalid start date at index ${i}:`, startDateValue);\n      continue;\n    }\n\n    // Parse end date if provided, otherwise use start date\n    let endDate = startDate;\n    if (endDateData && endDateData[i]) {\n      const parsedEndDate = parseDate(endDateData[i]);\n      if (parsedEndDate) {\n        endDate = parsedEndDate;\n      }\n    }\n\n    // Get other fields\n    const description = descriptionData && descriptionData[i] ? String(descriptionData[i]) : '';\n    const category = categoryData && categoryData[i] ? String(categoryData[i]) : 'Default';\n    const eventId = idData && idData[i] != null ? idData[i] : i;\n\n    // Add category to set\n    categories.add(category);\n\n    // Extract additional event fields\n    const additionalFields = {};\n    if (config.eventFields && Array.isArray(config.eventFields)) {\n      config.eventFields.forEach(fieldKey => {\n        if (eventFieldsData[fieldKey] && eventFieldsData[fieldKey][i] != null) {\n          const fieldName = getColumnName(elementColumns, fieldKey);\n          additionalFields[fieldName] = String(eventFieldsData[fieldKey][i]);\n        }\n      });\n    }\n\n    // Determine if this is an all-day event\n    const isAllDay = !hasTimeComponent(startDateValue) && !hasTimeComponent(endDateData?.[i]);\n\n    // Create event object\n    const event = {\n      id: eventId,\n      title: String(title),\n      start: startDate,\n      end: endDate,\n      allDay: isAllDay,\n      description,\n      category,\n      color: getEventColor(category, settings),\n      additionalFields,\n      originalIndex: i\n    };\n\n    // Debug event processing in development\n    if (process.env.NODE_ENV === 'development' && i < 3) {\n      debugEventProcessing(event, config, elementColumns);\n    }\n\n    events.push(event);\n  }\n\n  // Sort events by start date\n  events.sort((a, b) => a.start.getTime() - b.start.getTime());\n\n  console.log(`Processed ${events.length} events from ${dataLength} rows`);\n\n  return {\n    events,\n    categories: Array.from(categories),\n    stats: {\n      totalEvents: events.length,\n      totalRows: dataLength,\n      dateRange: events.length > 0 ? {\n        start: events[0].start,\n        end: events[events.length - 1].end\n      } : null\n    }\n  };\n}\n\n/**\n * Check if a date value has a time component\n * @param {any} dateValue - Date value to check\n * @returns {boolean} - True if has time component\n */\nfunction hasTimeComponent(dateValue) {\n  if (!dateValue) return false;\n  \n  const date = parseDate(dateValue);\n  if (!date) return false;\n  \n  // Check if time is not midnight (00:00:00)\n  return date.getHours() !== 0 || date.getMinutes() !== 0 || date.getSeconds() !== 0;\n}\n\n/**\n * Generate sample events for development/testing\n * @param {Date} startDate - Start date for sample events\n * @param {number} count - Number of events to generate\n * @returns {Object} - Calendar data with sample events\n */\nexport function generateSampleEvents(startDate = new Date(), count = 10) {\n  const events = [];\n  const categories = ['Meeting', 'Task', 'Deadline', 'Event', 'Review'];\n  const colors = ['#3788d8', '#f97316', '#ef4444', '#22c55e', '#8b5cf6'];\n\n  for (let i = 0; i < count; i++) {\n    const eventStart = addDays(startDate, Math.floor(Math.random() * 30));\n    const category = categories[Math.floor(Math.random() * categories.length)];\n    \n    events.push({\n      id: i + 1,\n      title: `Sample Event ${i + 1}`,\n      start: eventStart,\n      end: Math.random() > 0.7 ? addDays(eventStart, Math.floor(Math.random() * 3) + 1) : eventStart,\n      allDay: Math.random() > 0.5,\n      description: `This is a sample event description for event ${i + 1}`,\n      category,\n      color: colors[categories.indexOf(category)],\n      additionalFields: {\n        'Priority': ['Low', 'Medium', 'High'][Math.floor(Math.random() * 3)],\n        'Assignee': ['John Doe', 'Jane Smith', 'Bob Johnson'][Math.floor(Math.random() * 3)]\n      },\n      originalIndex: i\n    });\n  }\n\n  return {\n    events: events.sort((a, b) => a.start.getTime() - b.start.getTime()),\n    categories,\n    stats: {\n      totalEvents: events.length,\n      totalRows: events.length,\n      dateRange: {\n        start: events[0].start,\n        end: events[events.length - 1].end\n      }\n    }\n  };\n}\n\n/**\n * Filter events by date range\n * @param {Array} events - Array of events\n * @param {Date} startDate - Start date of range\n * @param {Date} endDate - End date of range\n * @returns {Array} - Filtered events\n */\nexport function filterEventsByDateRange(events, startDate, endDate) {\n  if (!events || !Array.isArray(events)) return [];\n  \n  return events.filter(event => {\n    const eventStart = event.start;\n    const eventEnd = event.end || event.start;\n    \n    // Event overlaps with the date range\n    return eventStart <= endDate && eventEnd >= startDate;\n  });\n}\n\n/**\n * Group events by date\n * @param {Array} events - Array of events\n * @returns {Object} - Events grouped by date string (YYYY-MM-DD)\n */\nexport function groupEventsByDate(events) {\n  if (!events || !Array.isArray(events)) return {};\n  \n  const grouped = {};\n  \n  events.forEach(event => {\n    const dateKey = format(event.start, 'yyyy-MM-dd');\n    if (!grouped[dateKey]) {\n      grouped[dateKey] = [];\n    }\n    grouped[dateKey].push(event);\n  });\n  \n  return grouped;\n}\n\n/**\n * Get events for a specific date\n * @param {Array} events - Array of events\n * @param {Date} date - Date to get events for\n * @returns {Array} - Events for the date\n */\nexport function getEventsForDate(events, date) {\n  if (!events || !Array.isArray(events) || !date) return [];\n  \n  const targetDate = startOfDay(date);\n  const nextDate = endOfDay(date);\n  \n  return events.filter(event => {\n    const eventStart = startOfDay(event.start);\n    const eventEnd = endOfDay(event.end || event.start);\n    \n    // Check if event spans this date\n    return eventStart <= targetDate && eventEnd >= targetDate;\n  });\n}\n\n/**\n * Validate calendar configuration\n * @param {Object} config - Configuration object\n * @returns {Object} - { isValid, errors }\n */\nexport function validateCalendarConfig(config) {\n  const errors = [];\n\n  if (!config.source) {\n    errors.push('Data source is required');\n  }\n\n  if (!config.title) {\n    errors.push('Event title column is required');\n  }\n\n  if (!config.startDate) {\n    errors.push('Start date column is required');\n  }\n\n  return {\n    isValid: errors.length === 0,\n    errors\n  };\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}