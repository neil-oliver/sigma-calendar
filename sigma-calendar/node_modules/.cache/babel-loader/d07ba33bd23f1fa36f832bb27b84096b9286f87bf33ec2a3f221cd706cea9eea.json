{"ast":null,"code":"/**\n * Get column name from column key using elementColumns\n * @param {Object} elementColumns - Column information from getElementColumns\n * @param {string} columnKey - Column key to look up\n * @returns {string} - Human readable column name or the key if not found\n */\nexport function getColumnName(elementColumns, columnKey) {\n  if (!elementColumns || !columnKey) {\n    return columnKey || '';\n  }\n\n  // Check if the column exists in elementColumns\n  if (elementColumns[columnKey] && elementColumns[columnKey].name) {\n    return elementColumns[columnKey].name;\n  }\n\n  // If not found, return the key itself (fallback)\n  return columnKey;\n}\n\n/**\n * Get column type from column key using elementColumns\n * @param {Object} elementColumns - Column information from getElementColumns\n * @param {string} columnKey - Column key to look up\n * @returns {string} - Column type or 'unknown' if not found\n */\nexport function getColumnType(elementColumns, columnKey) {\n  if (!elementColumns || !columnKey) {\n    return 'unknown';\n  }\n  if (elementColumns[columnKey] && elementColumns[columnKey].columnType) {\n    return elementColumns[columnKey].columnType;\n  }\n  return 'unknown';\n}\n\n/**\n * Validate that required columns exist in elementColumns\n * @param {Object} elementColumns - Column information from getElementColumns\n * @param {Array} requiredColumns - Array of column keys that are required\n * @returns {Object} - { isValid: boolean, missingColumns: Array }\n */\nexport function validateRequiredColumns(elementColumns, requiredColumns) {\n  if (!elementColumns || !requiredColumns) {\n    return {\n      isValid: false,\n      missingColumns: requiredColumns || []\n    };\n  }\n  const missingColumns = requiredColumns.filter(columnKey => !elementColumns[columnKey] || !elementColumns[columnKey].name);\n  return {\n    isValid: missingColumns.length === 0,\n    missingColumns\n  };\n}\n\n/**\n * Debug helper for event processing\n * @param {Object} event - Event object being processed\n * @param {Object} config - Configuration object\n * @param {Object} elementColumns - Column information from getElementColumns\n */\nexport function debugEventProcessing(event, config, elementColumns) {\n  console.log('Event Processing Debug:', {\n    event,\n    config,\n    titleColumn: config.title ? getColumnName(elementColumns, config.title) : 'Not set',\n    startDateColumn: config.startDate ? getColumnName(elementColumns, config.startDate) : 'Not set',\n    endDateColumn: config.endDate ? getColumnName(elementColumns, config.endDate) : 'Not set',\n    categoryColumn: config.category ? getColumnName(elementColumns, config.category) : 'Not set',\n    elementColumns\n  });\n}\n\n/**\n * Parse date value from various formats\n * @param {any} dateValue - Date value from Sigma data\n * @returns {Date|null} - Parsed date or null if invalid\n */\nexport function parseDate(dateValue) {\n  if (!dateValue) return null;\n\n  // If it's already a Date object\n  if (dateValue instanceof Date) {\n    return isNaN(dateValue.getTime()) ? null : dateValue;\n  }\n\n  // If it's a string or number, try to parse it\n  const parsed = new Date(dateValue);\n  return isNaN(parsed.getTime()) ? null : parsed;\n}\n\n/**\n * Format date for display\n * @param {Date} date - Date to format\n * @param {string} format - Format type ('short', 'long', 'time')\n * @returns {string} - Formatted date string\n */\nexport function formatDate(date, format = 'short') {\n  if (!date || !(date instanceof Date)) return '';\n  const options = {\n    short: {\n      month: 'short',\n      day: 'numeric'\n    },\n    long: {\n      weekday: 'long',\n      year: 'numeric',\n      month: 'long',\n      day: 'numeric'\n    },\n    time: {\n      hour: 'numeric',\n      minute: '2-digit'\n    },\n    datetime: {\n      month: 'short',\n      day: 'numeric',\n      hour: 'numeric',\n      minute: '2-digit'\n    }\n  };\n  return date.toLocaleDateString('en-US', options[format] || options.short);\n}\n\n/**\n * Check if a date value is valid\n * @param {any} dateValue - Value to check\n * @returns {boolean} - True if valid date\n */\nexport function isValidDate(dateValue) {\n  const date = parseDate(dateValue);\n  return date !== null && !isNaN(date.getTime());\n}\n\n/**\n * Get event color based on category\n * @param {string} category - Event category\n * @param {Object} colorSettings - Color settings from configuration\n * @returns {string} - Color value\n */\nexport function getEventColor(category, colorSettings = {}) {\n  if (!category) return '#3788d8'; // Default blue\n\n  // Check custom color mapping first\n  if (colorSettings.customEventColors && colorSettings.customEventColors[category]) {\n    return colorSettings.customEventColors[category];\n  }\n\n  // Default color palette for categories\n  const defaultColors = {\n    'urgent': '#ef4444',\n    // red\n    'high': '#f97316',\n    // orange\n    'medium': '#eab308',\n    // yellow\n    'low': '#22c55e',\n    // green\n    'completed': '#22c55e',\n    // green\n    'in progress': '#3b82f6',\n    // blue\n    'todo': '#6b7280',\n    // gray\n    'cancelled': '#6b7280' // gray\n  };\n  const categoryLower = category.toLowerCase();\n  if (defaultColors[categoryLower]) {\n    return defaultColors[categoryLower];\n  }\n\n  // Generate a consistent color based on category name\n  let hash = 0;\n  for (let i = 0; i < category.length; i++) {\n    hash = category.charCodeAt(i) + ((hash << 5) - hash);\n  }\n  const hue = Math.abs(hash) % 360;\n  return `hsl(${hue}, 65%, 55%)`;\n}","map":{"version":3,"names":["getColumnName","elementColumns","columnKey","name","getColumnType","columnType","validateRequiredColumns","requiredColumns","isValid","missingColumns","filter","length","debugEventProcessing","event","config","console","log","titleColumn","title","startDateColumn","startDate","endDateColumn","endDate","categoryColumn","category","parseDate","dateValue","Date","isNaN","getTime","parsed","formatDate","date","format","options","short","month","day","long","weekday","year","time","hour","minute","datetime","toLocaleDateString","isValidDate","getEventColor","colorSettings","customEventColors","defaultColors","categoryLower","toLowerCase","hash","i","charCodeAt","hue","Math","abs"],"sources":["/Users/neil/Documents/GitHub/sigma-calendar/sigma-calendar/src/utils/columnHelper.js"],"sourcesContent":["/**\n * Get column name from column key using elementColumns\n * @param {Object} elementColumns - Column information from getElementColumns\n * @param {string} columnKey - Column key to look up\n * @returns {string} - Human readable column name or the key if not found\n */\nexport function getColumnName(elementColumns, columnKey) {\n  if (!elementColumns || !columnKey) {\n    return columnKey || '';\n  }\n  \n  // Check if the column exists in elementColumns\n  if (elementColumns[columnKey] && elementColumns[columnKey].name) {\n    return elementColumns[columnKey].name;\n  }\n  \n  // If not found, return the key itself (fallback)\n  return columnKey;\n}\n\n/**\n * Get column type from column key using elementColumns\n * @param {Object} elementColumns - Column information from getElementColumns\n * @param {string} columnKey - Column key to look up\n * @returns {string} - Column type or 'unknown' if not found\n */\nexport function getColumnType(elementColumns, columnKey) {\n  if (!elementColumns || !columnKey) {\n    return 'unknown';\n  }\n  \n  if (elementColumns[columnKey] && elementColumns[columnKey].columnType) {\n    return elementColumns[columnKey].columnType;\n  }\n  \n  return 'unknown';\n}\n\n/**\n * Validate that required columns exist in elementColumns\n * @param {Object} elementColumns - Column information from getElementColumns\n * @param {Array} requiredColumns - Array of column keys that are required\n * @returns {Object} - { isValid: boolean, missingColumns: Array }\n */\nexport function validateRequiredColumns(elementColumns, requiredColumns) {\n  if (!elementColumns || !requiredColumns) {\n    return { isValid: false, missingColumns: requiredColumns || [] };\n  }\n  \n  const missingColumns = requiredColumns.filter(columnKey => \n    !elementColumns[columnKey] || !elementColumns[columnKey].name\n  );\n  \n  return {\n    isValid: missingColumns.length === 0,\n    missingColumns\n  };\n}\n\n/**\n * Debug helper for event processing\n * @param {Object} event - Event object being processed\n * @param {Object} config - Configuration object\n * @param {Object} elementColumns - Column information from getElementColumns\n */\nexport function debugEventProcessing(event, config, elementColumns) {\n  console.log('Event Processing Debug:', {\n    event,\n    config,\n    titleColumn: config.title ? getColumnName(elementColumns, config.title) : 'Not set',\n    startDateColumn: config.startDate ? getColumnName(elementColumns, config.startDate) : 'Not set',\n    endDateColumn: config.endDate ? getColumnName(elementColumns, config.endDate) : 'Not set',\n    categoryColumn: config.category ? getColumnName(elementColumns, config.category) : 'Not set',\n    elementColumns\n  });\n}\n\n/**\n * Parse date value from various formats\n * @param {any} dateValue - Date value from Sigma data\n * @returns {Date|null} - Parsed date or null if invalid\n */\nexport function parseDate(dateValue) {\n  if (!dateValue) return null;\n  \n  // If it's already a Date object\n  if (dateValue instanceof Date) {\n    return isNaN(dateValue.getTime()) ? null : dateValue;\n  }\n  \n  // If it's a string or number, try to parse it\n  const parsed = new Date(dateValue);\n  return isNaN(parsed.getTime()) ? null : parsed;\n}\n\n/**\n * Format date for display\n * @param {Date} date - Date to format\n * @param {string} format - Format type ('short', 'long', 'time')\n * @returns {string} - Formatted date string\n */\nexport function formatDate(date, format = 'short') {\n  if (!date || !(date instanceof Date)) return '';\n  \n  const options = {\n    short: { month: 'short', day: 'numeric' },\n    long: { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' },\n    time: { hour: 'numeric', minute: '2-digit' },\n    datetime: { month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit' }\n  };\n  \n  return date.toLocaleDateString('en-US', options[format] || options.short);\n}\n\n/**\n * Check if a date value is valid\n * @param {any} dateValue - Value to check\n * @returns {boolean} - True if valid date\n */\nexport function isValidDate(dateValue) {\n  const date = parseDate(dateValue);\n  return date !== null && !isNaN(date.getTime());\n}\n\n/**\n * Get event color based on category\n * @param {string} category - Event category\n * @param {Object} colorSettings - Color settings from configuration\n * @returns {string} - Color value\n */\nexport function getEventColor(category, colorSettings = {}) {\n  if (!category) return '#3788d8'; // Default blue\n  \n  // Check custom color mapping first\n  if (colorSettings.customEventColors && colorSettings.customEventColors[category]) {\n    return colorSettings.customEventColors[category];\n  }\n  \n  // Default color palette for categories\n  const defaultColors = {\n    'urgent': '#ef4444',     // red\n    'high': '#f97316',       // orange\n    'medium': '#eab308',     // yellow\n    'low': '#22c55e',        // green\n    'completed': '#22c55e',  // green\n    'in progress': '#3b82f6', // blue\n    'todo': '#6b7280',       // gray\n    'cancelled': '#6b7280'   // gray\n  };\n  \n  const categoryLower = category.toLowerCase();\n  if (defaultColors[categoryLower]) {\n    return defaultColors[categoryLower];\n  }\n  \n  // Generate a consistent color based on category name\n  let hash = 0;\n  for (let i = 0; i < category.length; i++) {\n    hash = category.charCodeAt(i) + ((hash << 5) - hash);\n  }\n  \n  const hue = Math.abs(hash) % 360;\n  return `hsl(${hue}, 65%, 55%)`;\n} "],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASA,aAAaA,CAACC,cAAc,EAAEC,SAAS,EAAE;EACvD,IAAI,CAACD,cAAc,IAAI,CAACC,SAAS,EAAE;IACjC,OAAOA,SAAS,IAAI,EAAE;EACxB;;EAEA;EACA,IAAID,cAAc,CAACC,SAAS,CAAC,IAAID,cAAc,CAACC,SAAS,CAAC,CAACC,IAAI,EAAE;IAC/D,OAAOF,cAAc,CAACC,SAAS,CAAC,CAACC,IAAI;EACvC;;EAEA;EACA,OAAOD,SAAS;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASE,aAAaA,CAACH,cAAc,EAAEC,SAAS,EAAE;EACvD,IAAI,CAACD,cAAc,IAAI,CAACC,SAAS,EAAE;IACjC,OAAO,SAAS;EAClB;EAEA,IAAID,cAAc,CAACC,SAAS,CAAC,IAAID,cAAc,CAACC,SAAS,CAAC,CAACG,UAAU,EAAE;IACrE,OAAOJ,cAAc,CAACC,SAAS,CAAC,CAACG,UAAU;EAC7C;EAEA,OAAO,SAAS;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,uBAAuBA,CAACL,cAAc,EAAEM,eAAe,EAAE;EACvE,IAAI,CAACN,cAAc,IAAI,CAACM,eAAe,EAAE;IACvC,OAAO;MAAEC,OAAO,EAAE,KAAK;MAAEC,cAAc,EAAEF,eAAe,IAAI;IAAG,CAAC;EAClE;EAEA,MAAME,cAAc,GAAGF,eAAe,CAACG,MAAM,CAACR,SAAS,IACrD,CAACD,cAAc,CAACC,SAAS,CAAC,IAAI,CAACD,cAAc,CAACC,SAAS,CAAC,CAACC,IAC3D,CAAC;EAED,OAAO;IACLK,OAAO,EAAEC,cAAc,CAACE,MAAM,KAAK,CAAC;IACpCF;EACF,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASG,oBAAoBA,CAACC,KAAK,EAAEC,MAAM,EAAEb,cAAc,EAAE;EAClEc,OAAO,CAACC,GAAG,CAAC,yBAAyB,EAAE;IACrCH,KAAK;IACLC,MAAM;IACNG,WAAW,EAAEH,MAAM,CAACI,KAAK,GAAGlB,aAAa,CAACC,cAAc,EAAEa,MAAM,CAACI,KAAK,CAAC,GAAG,SAAS;IACnFC,eAAe,EAAEL,MAAM,CAACM,SAAS,GAAGpB,aAAa,CAACC,cAAc,EAAEa,MAAM,CAACM,SAAS,CAAC,GAAG,SAAS;IAC/FC,aAAa,EAAEP,MAAM,CAACQ,OAAO,GAAGtB,aAAa,CAACC,cAAc,EAAEa,MAAM,CAACQ,OAAO,CAAC,GAAG,SAAS;IACzFC,cAAc,EAAET,MAAM,CAACU,QAAQ,GAAGxB,aAAa,CAACC,cAAc,EAAEa,MAAM,CAACU,QAAQ,CAAC,GAAG,SAAS;IAC5FvB;EACF,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASwB,SAASA,CAACC,SAAS,EAAE;EACnC,IAAI,CAACA,SAAS,EAAE,OAAO,IAAI;;EAE3B;EACA,IAAIA,SAAS,YAAYC,IAAI,EAAE;IAC7B,OAAOC,KAAK,CAACF,SAAS,CAACG,OAAO,CAAC,CAAC,CAAC,GAAG,IAAI,GAAGH,SAAS;EACtD;;EAEA;EACA,MAAMI,MAAM,GAAG,IAAIH,IAAI,CAACD,SAAS,CAAC;EAClC,OAAOE,KAAK,CAACE,MAAM,CAACD,OAAO,CAAC,CAAC,CAAC,GAAG,IAAI,GAAGC,MAAM;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,UAAUA,CAACC,IAAI,EAAEC,MAAM,GAAG,OAAO,EAAE;EACjD,IAAI,CAACD,IAAI,IAAI,EAAEA,IAAI,YAAYL,IAAI,CAAC,EAAE,OAAO,EAAE;EAE/C,MAAMO,OAAO,GAAG;IACdC,KAAK,EAAE;MAAEC,KAAK,EAAE,OAAO;MAAEC,GAAG,EAAE;IAAU,CAAC;IACzCC,IAAI,EAAE;MAAEC,OAAO,EAAE,MAAM;MAAEC,IAAI,EAAE,SAAS;MAAEJ,KAAK,EAAE,MAAM;MAAEC,GAAG,EAAE;IAAU,CAAC;IACzEI,IAAI,EAAE;MAAEC,IAAI,EAAE,SAAS;MAAEC,MAAM,EAAE;IAAU,CAAC;IAC5CC,QAAQ,EAAE;MAAER,KAAK,EAAE,OAAO;MAAEC,GAAG,EAAE,SAAS;MAAEK,IAAI,EAAE,SAAS;MAAEC,MAAM,EAAE;IAAU;EACjF,CAAC;EAED,OAAOX,IAAI,CAACa,kBAAkB,CAAC,OAAO,EAAEX,OAAO,CAACD,MAAM,CAAC,IAAIC,OAAO,CAACC,KAAK,CAAC;AAC3E;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASW,WAAWA,CAACpB,SAAS,EAAE;EACrC,MAAMM,IAAI,GAAGP,SAAS,CAACC,SAAS,CAAC;EACjC,OAAOM,IAAI,KAAK,IAAI,IAAI,CAACJ,KAAK,CAACI,IAAI,CAACH,OAAO,CAAC,CAAC,CAAC;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASkB,aAAaA,CAACvB,QAAQ,EAAEwB,aAAa,GAAG,CAAC,CAAC,EAAE;EAC1D,IAAI,CAACxB,QAAQ,EAAE,OAAO,SAAS,CAAC,CAAC;;EAEjC;EACA,IAAIwB,aAAa,CAACC,iBAAiB,IAAID,aAAa,CAACC,iBAAiB,CAACzB,QAAQ,CAAC,EAAE;IAChF,OAAOwB,aAAa,CAACC,iBAAiB,CAACzB,QAAQ,CAAC;EAClD;;EAEA;EACA,MAAM0B,aAAa,GAAG;IACpB,QAAQ,EAAE,SAAS;IAAM;IACzB,MAAM,EAAE,SAAS;IAAQ;IACzB,QAAQ,EAAE,SAAS;IAAM;IACzB,KAAK,EAAE,SAAS;IAAS;IACzB,WAAW,EAAE,SAAS;IAAG;IACzB,aAAa,EAAE,SAAS;IAAE;IAC1B,MAAM,EAAE,SAAS;IAAQ;IACzB,WAAW,EAAE,SAAS,CAAG;EAC3B,CAAC;EAED,MAAMC,aAAa,GAAG3B,QAAQ,CAAC4B,WAAW,CAAC,CAAC;EAC5C,IAAIF,aAAa,CAACC,aAAa,CAAC,EAAE;IAChC,OAAOD,aAAa,CAACC,aAAa,CAAC;EACrC;;EAEA;EACA,IAAIE,IAAI,GAAG,CAAC;EACZ,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG9B,QAAQ,CAACb,MAAM,EAAE2C,CAAC,EAAE,EAAE;IACxCD,IAAI,GAAG7B,QAAQ,CAAC+B,UAAU,CAACD,CAAC,CAAC,IAAI,CAACD,IAAI,IAAI,CAAC,IAAIA,IAAI,CAAC;EACtD;EAEA,MAAMG,GAAG,GAAGC,IAAI,CAACC,GAAG,CAACL,IAAI,CAAC,GAAG,GAAG;EAChC,OAAO,OAAOG,GAAG,aAAa;AAChC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}